### 6
#pragma omp parallel for reduction(+:sum_a, sum_b): Эта строка содержит директиву OpenMP.
Она сообщает компилятору о том, что цикл for должен быть выполнен параллельно.

reduction(+:sum_a, sum_b) указывает, что переменные sum_a и sum_b должны быть обработаны как переменные сокращения (reduction variables) с операцией сложения (+).
Это означает, что каждый поток будет иметь свою локальную копию sum_a и sum_b, а по завершении выполнения потоков, их значения будут сложены в общие переменные sum_a и sum_b.
___

### 7
omp_set_dynamic(0);: Эта функция отключает динамическое изменение числа потоков OpenMP.

omp_set_num_threads(t_cnt_a);: Задается количество потоков для первой параллельной области.

#pragma omp for schedule(static): Эта директива распределяет итерации цикла между потоками.
В данном случае используется статическое распределение, где итерации равномерно распределяются между потоками.
___

### 8
#pragma omp parallel

#pragma omp for schedule(static): Эта директива распределяет итерации цикла между потоками. В данном случае используется статическое распределение, где итерации равномерно распределяются между потоками.
Каждый поток будет выполнять одну часть итераций.
___

### 9
#pragma omp parallel for num_threads(threadCount): Эта строка запускает параллельный цикл for.
Количество потоков для выполнения параллельной области определяется переменной threadCount, которая, предположительно, определена в вашем коде.

#pragma omp critical { ... }: Эта директива указывает, что участок кода, заключенный в фигурные скобки, должен выполняться атомарно (только одним потоком одновременно).
В данном случае, если какой-либо поток находит элемент,
который больше текущего максимального значения, или меньше текущего минимального значения, он обновляет соответствующую переменную (max или min) атомарно.
___

### 10
#pragma omp atomic обеспечивает атомарное выполнение операции увеличения count9++.

#pragma omp parallel for num_threads(threadCount): Эта директива OpenMP создает параллельный цикл for. Она указывает, что цикл for должен быть выполнен параллельно.
___

### 11

#pragma omp parallel for shared(max): Эта директива создает параллельный цикл, в котором итерации цикла выполняются параллельно.
Переменная max объявлена как общая (shared) для всех потоков, что означает, что все потоки будут иметь доступ к этой переменной.

#pragma omp critical { mx7 = a[i]; }: Эта директива critical гарантирует, что только один поток может выполнить блок кода внутри фигурных скобок одновременно.
Это предотвращает возможные гонки данных (race conditions), когда несколько потоков пытаются одновременно обновить mx7.
___

### 12
#pragma omp barrier: Эта директива создает барьер синхронизации. Все потоки должны достичь барьера, прежде чем продолжить выполнение.
Это гарантирует, что все потоки закончили свои текущие операции перед продолжением.
___

### 13

omp_set_dynamic(0); : Отключает динамическое изменение числа потоков OpenMP.

#pragma omp parallel for reduction(+:res): Эта строка начинает параллельный блок кода с директивой OpenMP.
Цикл for внутри этого блока будет выполнен параллельно.
Директива reduction(+:res) указывает, что переменная res должна быть обработана как переменная сокращения (reduction variable) с операцией сложения (+).
___

### 14

#pragma omp parallel for reduction(+:res): Эта директива говорит OpenMP о параллельном выполнении цикла for, а также указывает,
что переменная res является переменной сокращения (reduction variable) и должна складываться (+) по завершении вычислений в каждом потоке.
___

### 15
#pragma omp parallel for for (int j = 2 * i; j <= right; j += i) { prime[j] = false; }:
Здесь используется директива OpenMP #pragma omp parallel for,чтобы распараллелить внутренний цикл.
Внутренний цикл перебирает все кратные числа i в заданном диапазоне от 2 * i до right с шагом i и устанавливает соответствующие элементы массива prime в false,
обозначая, что эти числа не являются простыми.